@namespace MediaIngesterCore.Parsing
@classname Parser
@using MediaIngesterCore.Parsing.SyntaxTree
@using MediaIngesterCore.Parsing.SyntaxTree.Conditions
@trace true
@start program


program<ProgramNode>
 = #{ state["Indentation"] = 0; } v:variableBlock (EOL _*)+ b:block{new ProgramNode(v,b)} 

variableBlock<VarBlockNode>
  = head:assign (EOL _*)+ tail:variableBlock { new VarBlockNode(head).Concat(tail)}
  / line:assign _* { new VarBlockNode(line) }

block<BlockNode>
  = INDENTATION head:rule _* (EOL _*)+ tail:block { new BlockNode(head).Concat(tail)}
  / INDENTATION line:rule _*{ new BlockNode(line) }


expression<SyntaxNode> 
  = "path[" p:("" [0-9\-]+) "]" {new PathPartNode(int.Parse(p))}
  / d:(""[^":]+) ":"  t:(""[^:"}]+)":" {new MetadataNode(d,t)}
  / lookup
  / value
  

assign<AssignNode> = name:varName " = " e:expression {new AssignNode(name,e)}      
lookup<LookupNode> = name:varName {new LookupNode(name)}
varName = ("" [A-Za-z0-9_]+)

value<ValueNode> 
  = '"' v:((stringPart))+ '"'  {new ValueNode(new List<SyntaxNode>(v))}
  / 'r"' v:(""[^\r\n"]+) '"'  {new ValueNode(new List<SyntaxNode>(1){new LiteralNode(v)})}


stringPart<SyntaxNode>  
  = stringInterpolation 
  / literal

stringInterpolation<LookupNode> = "{" v:lookup "}" {v}
literal<LiteralNode> = v:escapedString {new LiteralNode(v)}

escapedString<string>
  = v:("\\"? !stringInterpolation c:("" [^\r\n"]) {c})+ {v.Aggregate((a,b) => a+b)}

rule<RuleNode> 
  = (c:compositeCondition _ '-->' _ p:path _*  EOL INDENTATION r:rule) {new RuleNode(c,p,r,new EmptyNode())}
  / (c:compositeCondition _ '-->' _ p:path _* EOL INDENT b:block UNDENT) {new RuleNode(c,p,new EmptyNode(),b)} 
  / (c:compositeCondition _ '-->' _ p:path ) {new RuleNode(c,p,new EmptyNode(),new EmptyNode())}


path<SyntaxNode>
  = expression
  / ignore
  / empty

ignore<IgnoreNode> = "!" {new IgnoreNode()}
empty<ValueNode> = "?" {new ValueNode(new List<SyntaxNode>(1){new LiteralNode("")})}

compositeCondition<SyntaxNode>
  = "not" _? "("? c:condition")"? {new NotNode(c)}
  / condition

condition<ConditionNode> 
  = ('any') {new AnyNode()}
  / (l:expression _? ('=='/"equals") _? r:expression) {new EqualsNode(l,r)}
  / (l:expression _? ('!='/"not equals")_? r:expression) {new NotEqualsNode(l,r)}
  / (l:expression _? "matches" _? r:expression) {new MatchesNode(l,r)}
  / (l:expression _? "matches" _? r:expression) {new ContainsNode(l,r)}

_ = [\t ]+
EOL = '\n' / '\r\n'

INDENTATION
  = spaces:" "* &{ spaces.Count == state["Indentation"] }

INDENT
  = #{ state["Indentation"] += 4; }

UNDENT
  = #{ state["Indentation"] -= 4; }